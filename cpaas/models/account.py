# coding: utf-8

"""
    cpaas api

    # Overview  mGage CPaaS API lets you interact with the CPaaS platform. It allows you to query your account, set up webhooks, send messages and buy phone numbers.  # API and Clients Versioning  CPaaS APIs are versioned using the format vX.Y where X is the major version number and Y is minor. All minor version changes are backwards compatible. Major releases are not, please be careful when upgrading.  A new account is pinned to the latest version at the time of first request. By default every request sent CPaaS is processed using that version, even if there have been subsequent breaking changes. This is done to prevent existing user applications from breaking. You can change the pinned version for your account using the account dashboard. The default API version can be overridden by specifying the header `api-version`. Note: Specifying this value will not change your pinned version for other calls.  CPaaS also provides HTTP API clients for all major languages. Release versions of these clients correspond to their API Version supported. Client version vX.Y.Z supports API version vX.Y. HTTP Clients are configured to use `api-version` header for that client version. When using official CPaaS HTTP Clients only, you dont need to concern yourself with pinned version. To upgrade your API version simply update the client.  # Common Response format  All CPaaS APIs follow a common response format. Each response will have a `meta` field which contains metadata about the response (like the request_uuid).  APIs which return a single object will have a field `data` which contains the object being returned.  APIs which return a list of objects will have a field `objects` which contains the list of objects being returned.  ## Pagination Pagination for list APIs are controlled using query parameters:   - `limit`: Number of objects to be returned   - `offset`: Number of objects to skip before collecting the output list.  These fields are also present in the response under the field `meta`. 

    OpenAPI spec version: 1.0
    Contact: apiteam@mgageindia.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from pprint import pformat
from six import iteritems
import re


class Account(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """


    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'name': 'str',
        'status': 'str',
        'uid': 'str',
        'token': 'str',
        'is_parent': 'bool',
        'created_time': 'datetime',
        'updated_time': 'datetime',
        'account_type': 'str',
        'credit_balance': 'float',
        'auto_recharge': 'bool'
    }

    attribute_map = {
        'name': 'name',
        'status': 'status',
        'uid': 'uid',
        'token': 'token',
        'is_parent': 'is_parent',
        'created_time': 'created_time',
        'updated_time': 'updated_time',
        'account_type': 'account_type',
        'credit_balance': 'credit_balance',
        'auto_recharge': 'auto_recharge'
    }

    def __init__(self, name=None, status=None, uid=None, token=None, is_parent=None, created_time=None, updated_time=None, account_type=None, credit_balance=None, auto_recharge=None):
        """
        Account - a model defined in Swagger
        """

        self._name = None
        self._status = None
        self._uid = None
        self._token = None
        self._is_parent = None
        self._created_time = None
        self._updated_time = None
        self._account_type = None
        self._credit_balance = None
        self._auto_recharge = None

        self.name = name
        if status is not None:
          self.status = status
        if uid is not None:
          self.uid = uid
        if token is not None:
          self.token = token
        if is_parent is not None:
          self.is_parent = is_parent
        if created_time is not None:
          self.created_time = created_time
        if updated_time is not None:
          self.updated_time = updated_time
        if account_type is not None:
          self.account_type = account_type
        if credit_balance is not None:
          self.credit_balance = credit_balance
        if auto_recharge is not None:
          self.auto_recharge = auto_recharge

    @property
    def name(self):
        """
        Gets the name of this Account.
        Name of the account. Must be unique within the parent account. 

        :return: The name of this Account.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """
        Sets the name of this Account.
        Name of the account. Must be unique within the parent account. 

        :param name: The name of this Account.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")

        self._name = name

    @property
    def status(self):
        """
        Gets the status of this Account.
        Status of your account. Possible values are:   - enabled: Account is ready to be used   - suspended: Account has been temporarily suspended   - disabled: Account has been permanently disabled and             cannot be revived. All resources allocated             to the subaccount like phonenumbers are also             deleted. 

        :return: The status of this Account.
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """
        Sets the status of this Account.
        Status of your account. Possible values are:   - enabled: Account is ready to be used   - suspended: Account has been temporarily suspended   - disabled: Account has been permanently disabled and             cannot be revived. All resources allocated             to the subaccount like phonenumbers are also             deleted. 

        :param status: The status of this Account.
        :type: str
        """
        allowed_values = ["enabled", "suspended", "disabled"]
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}"
                .format(status, allowed_values)
            )

        self._status = status

    @property
    def uid(self):
        """
        Gets the uid of this Account.
        Alphanumeric user identification. Used as username for Basic Authentication 

        :return: The uid of this Account.
        :rtype: str
        """
        return self._uid

    @uid.setter
    def uid(self, uid):
        """
        Sets the uid of this Account.
        Alphanumeric user identification. Used as username for Basic Authentication 

        :param uid: The uid of this Account.
        :type: str
        """

        self._uid = uid

    @property
    def token(self):
        """
        Gets the token of this Account.
        Token password for this account. Used as password in Basic Authentication 

        :return: The token of this Account.
        :rtype: str
        """
        return self._token

    @token.setter
    def token(self, token):
        """
        Sets the token of this Account.
        Token password for this account. Used as password in Basic Authentication 

        :param token: The token of this Account.
        :type: str
        """

        self._token = token

    @property
    def is_parent(self):
        """
        Gets the is_parent of this Account.
        There is generally only one parent account in list. Rest are child subaccounts. Possible values:   - `true`: If the account is a parent account   - `false`: If the account is a subaccount with a parent account 

        :return: The is_parent of this Account.
        :rtype: bool
        """
        return self._is_parent

    @is_parent.setter
    def is_parent(self, is_parent):
        """
        Sets the is_parent of this Account.
        There is generally only one parent account in list. Rest are child subaccounts. Possible values:   - `true`: If the account is a parent account   - `false`: If the account is a subaccount with a parent account 

        :param is_parent: The is_parent of this Account.
        :type: bool
        """

        self._is_parent = is_parent

    @property
    def created_time(self):
        """
        Gets the created_time of this Account.
        Date when this account was created

        :return: The created_time of this Account.
        :rtype: datetime
        """
        return self._created_time

    @created_time.setter
    def created_time(self, created_time):
        """
        Sets the created_time of this Account.
        Date when this account was created

        :param created_time: The created_time of this Account.
        :type: datetime
        """

        self._created_time = created_time

    @property
    def updated_time(self):
        """
        Gets the updated_time of this Account.
        Date when this account was last updated

        :return: The updated_time of this Account.
        :rtype: datetime
        """
        return self._updated_time

    @updated_time.setter
    def updated_time(self, updated_time):
        """
        Sets the updated_time of this Account.
        Date when this account was last updated

        :param updated_time: The updated_time of this Account.
        :type: datetime
        """

        self._updated_time = updated_time

    @property
    def account_type(self):
        """
        Gets the account_type of this Account.
        Signifies whether the account is prepaid or postpaid 

        :return: The account_type of this Account.
        :rtype: str
        """
        return self._account_type

    @account_type.setter
    def account_type(self, account_type):
        """
        Sets the account_type of this Account.
        Signifies whether the account is prepaid or postpaid 

        :param account_type: The account_type of this Account.
        :type: str
        """
        allowed_values = ["prepaid", "postpaid"]
        if account_type not in allowed_values:
            raise ValueError(
                "Invalid value for `account_type` ({0}), must be one of {1}"
                .format(account_type, allowed_values)
            )

        self._account_type = account_type

    @property
    def credit_balance(self):
        """
        Gets the credit_balance of this Account.
        Account's credit balance in US dollars. For subaccounts this value will be `null`. 

        :return: The credit_balance of this Account.
        :rtype: float
        """
        return self._credit_balance

    @credit_balance.setter
    def credit_balance(self, credit_balance):
        """
        Sets the credit_balance of this Account.
        Account's credit balance in US dollars. For subaccounts this value will be `null`. 

        :param credit_balance: The credit_balance of this Account.
        :type: float
        """

        self._credit_balance = credit_balance

    @property
    def auto_recharge(self):
        """
        Gets the auto_recharge of this Account.
        Whether auto-recharge has been enabled. 

        :return: The auto_recharge of this Account.
        :rtype: bool
        """
        return self._auto_recharge

    @auto_recharge.setter
    def auto_recharge(self, auto_recharge):
        """
        Sets the auto_recharge of this Account.
        Whether auto-recharge has been enabled. 

        :param auto_recharge: The auto_recharge of this Account.
        :type: bool
        """

        self._auto_recharge = auto_recharge

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        if not isinstance(other, Account):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
